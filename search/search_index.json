{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Getting started with the Venafi Firefly Playground.","text":"","tags":["v0.1"]},{"location":"#getting-started-with-the-venafi-firefly-playground","title":"Getting started with the Venafi Firefly Playground.","text":"","tags":["v0.1"]},{"location":"#overview","title":"Overview","text":"<p>This quick-start playground is intended to showcase Venafi's Firefly ephemeral CA in the shortest possible time. Assuming the following prerequisites, it should take less than 60 seconds to deploy a fully functioning Firefly instance in a Github CodeSpaces or local Docker environment. </p> <p>For simplicity the demo will use a built in certificate authority CA provided by as part of the Venafi Cloud service. </p>","tags":["v0.1"]},{"location":"#architecture","title":"Architecture","text":"<p>The following diagram provides a high level architectural overview that shows the outcome of what we will be building: </p> <p></p>","tags":["v0.1"]},{"location":"#prerequisites","title":"Prerequisites","text":"<p>This playground can be run in one of two ways as follows: </p> Option Description   GitHub CodeSpaces This is the quickest and easiest way to get started as there are no local dependencies. The codespace includes everything you need to try Firefly in your own GitHub dev container.  Local Docker This option can be used to run Firefly on your local machine and has additional dependencies <ul> <li>Run directly from GitHub CodeSpaces - no local dependencies</li> <li>Clone the repository and run in your own Docker environment - with local dependencies    ffdsfds</li> </ul> <p>Dependencies</p> Run Playground in GitHub CodeSpacesRun Playground in local Docker environment <p>The following prerequisites can be used to run the Firefly playground in a GitHub CodeSpaces environment. This easiest and quickest way to get started and has no local dependencies and can be run entirely in a browser. </p> <ul> <li>A working GitHub account </li> <li>Venafi Cloud account for Firefly - you can signup for a free 30 day trial here</li> <li>An API key for your Venafi Cloud account. Use the instructions in the info panel below to get your API key.</li> </ul> <p>The following prerequisites can be used to run the Firefly playground in your own Docker environment. This option has has mandatory and some optional local dependencies.</p> <ul> <li>Access to a fairly recent Docker runtime environment </li> <li>Venafi Cloud account for Firefly - you can signup for a free 30 day trial here</li> <li>An API key for your Venafi Cloud account. Use the instructions in the info panel below to get your API key.</li> <li>The following utilities are not required to run the Firefly playground but are used as a convenience to quickly demonstrate the Firefly API.     <ul> <li>Locally installed (cURL)[https://curl.se] command line utility</li> <li>Locally installed (JQ)[https://jqlang.github.io/jq/] command line utility</li> <li>Locally installed (OpenSSL)[https://www.openssl.org] command line utility</li> <li>Locally installed (JWT)[https://github.com/mike-engel/jwt-cli] command line utility</li> </ul> </li> </ul> Getting an API Key <p>If you don't have an API key you can follow this steps: </p> <ol> <li>Login to https://ui.venafi.cloud. If you don't already have an account you can sign-up for a 30 day trail. </li> <li>In the menu bar, click your avatar in the top-right corner, and then click Preferences.  </li> <li>Click the \"Generate New Key\" link, then specify the \"API Key Validity Period\". Recommend 30 days.  </li> <li>Click the \"Generate\" button at the bottom of the page. You will then see options to view or copy the new key. Keep a note of the API key somewhere secure for later </li> </ol>","tags":["v0.1"]},{"location":"#audience","title":"Audience","text":"<p>The intended audience for this playground is: </p> <ul> <li>New or existing Venafi customers wanting to quickly see Firefly working within their own environments.</li> <li>InfoSec teams wanting to learn more about service that they can provide to cloud native developers, SRE's and platform engineering teams.</li> <li>Developers, SRE's and platform engineering teams wanting to learn more about the services that Info Sec teams should be providing </li> <li>Internal Venafi staff wanting to demonstrate Firefly to partners and customers.</li> </ul>","tags":["v0.1"]},{"location":"#getting-started","title":"Getting Started","text":"<p>The quick-start demo runs entirely in Docker and consists of three container images that a pulled from the public Docker repositories. </p> <p> 3goats/elevate - This a utility application that automates all of the required Venafi SaaS (control plane tasks) that would ordinarily be performed by an InfoSec team. Whilst these tasks can be performed manually, the utility helps by fully automating the configuration, thus new users get to see Firefly working much quicker.</p> <p> tr1ck3r/jwt-this - jwt-this (pronounced \"jot this\") is a command line utility I created to simplify demonstration, evaluation, and simple testing with Venafi Firefly. When run, it generates a new signing key pair, uses it to sign and output a new JSON Web Token (JWT) containing specified Firefly-related claims, and starts a basic HTTP server (listening on port 8000 by default) where the signing public key is published via a JSON Web Key Set (JWKS) so it can be used by Firefly to verify the signature of the JWT.</p> <p> public.ecr.aws/venafi-images/firefly - This is the main Firefly instance that will be initialised for the demonstration</p> <p>To start the demo using Github CodeSpaces, use the steps in following info panel.</p> Launching the Firefly Playground using Github CodeSpaces <p>A codespace is a development environment that's hosted in the cloud. The Firefly playground GitHub repository provides a custom dev container that includes all of the prerequisites that are required:</p> <ol> <li>Login to your GitHub account and goto https://github.com/Venafi/firefly-playground</li> <li> <p>Create a new CodeSpace by clicking on the \"Code\" button, then \"Create codespace on main\" e.g. </p> <p></p> </li> <li> <p>This will build and launch a new dev container which will take a few minutes to complete. You should then see a new development environment. e.g. </p> <p></p> </li> </ol> <p>Important</p> <p>Before you start using the new CodeSpace wait for the <code>PostCreateCommand</code> to finish installing the dependencies for the dev container.</p>","tags":["v0.1"]},{"location":"#running-the-firefly-demo","title":"Running the Firefly Demo","text":"<p>To simplify the this demonstration, the project includes an interactive Jupyter (formerly IPython Notebook) notebook that includes all of the required commands. However, please note that this does not include some of the Docker commands which must be run from the terminal. To continue open the <code>demo.ipynb</code> file and follow the steps from there. </p> Important <p>Before you can run Firefly, you must edit the <code>.env</code> file to include a valid Venafi cloud API key (referenced in the prerequisites) at the placeholder. This is the only thing you need to change.</p> <p>The first task in the demo creates a <code>.env</code> file that is used to store a variable for the API key.</p> <p>e.g. </p> create a .env file<pre><code>echo \"TLSPC_API_KEY=xxxxx-xxxxxx-xxxxxx-xxxxxx\" &gt; .env\n</code></pre> <p>At this point you can either follow the instructions here and cut/past the commands into the terminal in the codesdpace, or just step through and run each of the cells in the <code>demo.ipynb</code> interactive notebook file.</p>","tags":["v0.1"]},{"location":"#step-1-configure-the-control-plane","title":"Step 1   - Configure the control plane","text":"<p>Every Firefly instance requires a valid service account, configuration and policy in the Venafi Control Plane (TLS Protect Cloud). For production, this task would often be completed by your InfoSec team. However, it might be undertaken by the platform engineering teams. Either way, you need to login to https://ui.venafi.cloud to create various config items. </p> <p>To simplify this process and reduce the time it takes to get started, we will use the prebuilt <code>3goats/elevate</code> container that fully automates the creation of the service account, configuration and policy. It will also create a private key file <code>private-key.pem</code> and local firefly <code>config.yaml</code> in the <code>config</code> directory.  </p> <p>To do this use the following <code>docker compose</code> command. This will run only the <code>3goats/elevate</code> container.</p> Important <p>Do not run the <code>docker</code> commands in the interactive <code>demo.ipynb</code> environment. Instead type or cut and past the commands into the terminal. </p> Configure the Control Plane<pre><code>docker compose --profile control-plane up\n</code></pre> <p>You should see the following output.  </p>Example output<pre><code>[+] Running 2/0\n \u2714 Network firefly-quickstart_default      Created  0.0s \n \u2714 Container firefly-quickstart-elevate-1  Created  0.0s \nAttaching to elevate-1\nelevate-1  | \nelevate-1  | bootstrap:\nelevate-1  |   vaas:\nelevate-1  |     url: https://api.venafi.cloud \nelevate-1  |     auth:\n...\nelevate-1 exited with code 0\n</code></pre><p></p> <p>The following files should now have been updated to include valid content in the  <code>./config</code> directory. </p> <ul> <li>config.yaml - This is a generated Firefly configuration that will be used to pass the Firefly instance some basic values that are required as part of the bootstrap process,</li> <li>private-key.pem This is the private part of a generated key pair that will be used by firefly to authenticate to the Venafi Cloud control plane.  </li> </ul> <p>If you take a look at the <code>config.yaml</code> it will look something like this:</p> config.yaml<pre><code> bootstrap:\n   vaas:\n     url: https://api.venafi.cloud # (1)\n     auth:\n       privateKeyFile: /etc/firefly/private-key.pem  # (2)\n       clientID: 8104b51c-bf7e-11ee-9c78-4a98e9dd68c7  # (3)\n     csr:\n       instanceNaming: Firefly Playground # (4)\n server: # (5)\n   rest: # (6)\n     port: 8281 # (7)\n     tls: # (8)\n       dnsNames: # (9)\n       - firefly.venafi.example\n       ipAddress: 127.0.0.1 # (10)\n</code></pre> <ol> <li> This is the url for the Venafi control plane API.</li> <li> The path to the private key that will be used to authenticate the Firefly instance to the Venafi control plane. The corresponding public key is stored in the control plane definition for the service account.</li> <li> This is a reference to the <code>clientID</code> that will be used to authenticate the Firefly instance.</li> <li> A name that will be used to identify the Firefly instance in the control plane.</li> <li> Firefly will run in server mode and expose networking ports. Firefly can also run in Kubernetes operator mode and will not expose networking ports.</li> <li> Firefly will expose a REST API. Firefly supports REST, GraphQL and gRPC.</li> <li> The port used for the REST API.</li> <li> Define the TLS configuration for the REST API.</li> <li> A list of FQDN's that will be used to represent the Firefly instance in the auto generated TLS certificate used for the REST API.</li> <li> The IP address used for the REST API.</li> </ol> <p>Firefly Configuration file</p> <p>Click on the <code>+</code> symbols in the output above to learn more about how Firefly uses the local <code>config.yaml</code> file. </p>","tags":["v0.1"]},{"location":"#step-2-start-firefly-and-the-local-jwt-service","title":"Step 2  - Start Firefly and the local JWT service","text":"<p>Now that we've configured the Control Plane, we can now start the Firefly container <code>public.ecr.aws/venafi-images/firefly</code> and the <code>tr1ck3r/jwt-this</code>. </p> <p>To do this use the following <code>docker compose</code> command. The <code>--profile firefly</code> flag tells Docker to run only the <code>public.ecr.aws/venafi-images/firefly</code> and the <code>tr1ck3r/jwt-this</code> containers.</p> Start Firefly &amp; the JWT service<pre><code>docker compose --profile firefly up\n</code></pre> <p>This will create 2 containers</p> <p>You should see the following output. </p> Example output - Truncated<pre><code>docker compose --profile firefly up\n[+] Running 2/0\n \u2714 Container firefly-playground-jwt-this-1  Created                                                                                                                   0.0s \n \u2714 Container firefly-playground-firefly-1   Created                                                                                                                   0.0s \nAttaching to firefly-1, jwt-this-1\njwt-this-1  | Token\njwt-this-1  | =====\njwt-this-1  | eyJhbGciOiJFUzI1NiIsImtpZCI6Im8weWttRGFUTDZhU283WnVGUFRQaDVKbWdkYjBjVnVJMklLX1lUQ0ZtQmciLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDczOTUzOTksImlhdCI6MTcwNzMwODk5OSwiaXNzIjoiaHR0cDovLzE3Mi4xOC4wLjI6ODAwMCIsInN1YiI6Imp3dC10aGlzIiwidmVuYWZpLWZpcmVmbHkuYWxsb3dBbGxQb2xpY2llcyI6ZmFsc2UsInZlbmFmaS1maXJlZmx5LmFsbG93ZWRQb2xpY2llcyI6WyJCYXNpYyBEZW1vIl0sInZlbmFmaS1maXJlZmx5LmNvbmZpZ3VyYXRpb24iOiJCYXNpYyBEZW1vIn0.PM0S76Dp47GDV6lnKxTYQdi2rlNpTsCFHAZdJRJWSvqm6Vu8jdjBAm3DYL9wxJV0j-RK_d5w2s2x-lv7zaUizQ\njwt-this-1  | \njwt-this-1  | Header\njwt-this-1  | ======\njwt-this-1  | {\njwt-this-1  |   \"alg\": \"ES256\",\njwt-this-1  |   \"kid\": \"o0ykmDaTL6aSo7ZuFPTPh5Jmgdb0cVuI2IK_YTCFmBg\",\njwt-this-1  |   \"typ\": \"JWT\"\njwt-this-1  | }\njwt-this-1  | \njwt-this-1  | Claims\njwt-this-1  | ======\njwt-this-1  | {\njwt-this-1  |   \"exp\": 1707395399,\njwt-this-1  |   \"iat\": 1707308999,\n...\nfirefly-1   | I0207 12:30:00.469163       1 options.go:141] \"msg\"=\"process successfully set mlockall()\" \nfirefly-1   | I0207 12:30:00.479032       1 client.go:195] \"msg\"=\"creating vaas client\" \"logger\"=\"client\"\nfirefly-1   | I0207 12:30:00.479230       1 client.go:241] \"msg\"=\"getting VaaS configuration\" \"logger\"=\"client\"\nfirefly-1   | I0207 12:30:01.090982       1 readyz.go:68] \"msg\"=\"adding readiness check\" \"logger\"=\"agent.manager.readyz\" \"name\"=\"signer/inmemory\" \"path\"=\"/readyz\"\nfirefly-1   | I0207 12:30:01.091020       1 client.go:195] \"msg\"=\"creating vaas client\" \"logger\"=\"agent.bootstrap.vaas.client\"\n...\nfirefly-1   | I0207 12:30:02.061899       1 client.go:296] \"msg\"=\"retrieve issued intermediate certificate from VaaS\" \"logger\"=\"agent.bootstrap.vaas.client\"\nfirefly-1   | I0207 12:30:02.169560       1 vaas.go:123] \"msg\"=\"issued intermediate certificate from VaaS\" \"CN\"=\"Firefly Playground Issuer\" \"id\"=\"9d03a130-c5b4-11ee-b282-75b352d68206\" \"logger\"=\"agent.bootstrap.vaas\"\nfirefly-1   | I0207 12:30:02.172270       1 inmemory.go:49] \"msg\"=\"stored in memory certificate private key bundle\" \"logger\"=\"agent.signer.inmemory\"\nfirefly-1   | I0207 12:30:02.172303       1 renewer.go:135] \"msg\"=\"fetched intermediate certificate from bootstrap\" \"CN\"=\"Firefly Playground Issuer\" \"logger\"=\"agent.agent_renewer\"\nfirefly-1   | I0207 12:30:02.172324       1 renewer.go:169] \"msg\"=\"waiting to renew certificate\" \"logger\"=\"agent.agent_renewer\" \"renew_time\"=\"2024-04-07 12:29:51 +0000 UTC\"\nfirefly-1   | I0207 12:30:02.172328       1 tls.go:144] \"msg\"=\"signing tls certificate\" \"logger\"=\"agent.server.rest.tls\"\nfirefly-1   | I0207 12:30:02.173788       1 tls.go:169] \"msg\"=\"signed tls certificate\" \"logger\"=\"agent.server.rest.tls\" \"renewal_time\"=\"2024-02-08T04:30:02Z\"\n</code></pre> <p>Note</p> <p>The above command runs docker in interactive mode which means that the process does not exit. Be careful not to accidentally exit the process.</p>","tags":["v0.1"]},{"location":"#step-3-create-a-new-jwt","title":"Step 3   - Create a new JWT","text":"<p>When running in <code>server mode</code> all certificate requests will require a valid JWT to be provided in the HTTP <code>auth</code> header. i.e. the request must include a </p> Authorization Header<pre><code>Authorization: Bearer eyJhbGciOiJFUzI1NiIsImtpZCI6IlNVVkQwc3NlNGxNcWhQ... \n</code></pre> <p>Lets use cURL get a JWT using using the <code>jwt-this</code> service. This creates a new environment variable <code>$token</code> that stores the token.  </p> cURL Usage to request JWT<pre><code>token=$( curl -H \"Content-Type: application/x-www-form-urlencoded\" \\\n     -X POST http://localhost:8001/token \\\n     -k -s |  jq -r  '.access_token' ) \n</code></pre> <p>You can decode and see the JWT content using a nifty trick with the <code>jq</code> command. e.g.</p> JQ Usage to decode JWT<pre><code>echo ${token} | jq -R 'split(\".\") | .[0],.[1] | @base64d | fromjson'\n</code></pre> Output<pre><code>{\n  \"alg\": \"ES256\",\n  \"kid\": \"fsX3WvpPBwpi_YK91dCulTrSQj6ogkGKb6V58Pj7Eaw\",\n  \"typ\": \"JWT\"\n}\n{\n  \"email\": \"user1@acme.com\",\n  \"exp\": 1707401178,\n  \"iat\": 1707314778,\n  \"iss\": \"http://172.18.0.2:8000\",\n  \"sub\": \"jwt-this\",\n  \"venafi-firefly.allowAllPolicies\": false,\n  \"venafi-firefly.allowedPolicies\": [ # (1)\n    \"Firefly Playground\"\n  ],\n  \"venafi-firefly.configuration\": \"Firefly Playground\" # (2)\n}\n</code></pre> <ol> <li> Determines what certificate issuing policies the requestor is allowed to use</li> <li> Determines what Firefly configuration the requestor is allowed to use</li> </ol> <p>Note the <code>venafi-firefly.allowAllPolicies</code>, <code>venafi-firefly.allowedPolicies</code> and <code>venafi-firefly.configuration</code> fields. </p>","tags":["v0.1"]},{"location":"#step-4-create-a-certificate-signing-request-csr","title":"Step 4  - Create a Certificate Signing Request (CSR)","text":"<p>Before we can request a new certificate we first need to create a Certificate Signing Request (CSR). To keep things simple we'll just use <code>openssl</code> to create this. We'll then store it as another environment variable called <code>$csr</code>. Because we need to format the CSR as JSON string this is a 2 step process. </p> openssl Usage to request create CSR<pre><code># Step 1. (1)\ntmp=$(openssl req -nodes -newkey rsa:2048 -keyout example.key -out - -subj \"/C=GB/ST=London/L=London/O=Global Security/OU=IT Department/CN=test.example.com\" 2&gt;/dev/null) \n# Step 2. (2)\ncsr=$( jq -n --arg string \"$tmp\" '$string' | tr -d '\"' ) \n</code></pre> <ol> <li> Store's the CSR in PEM format</li> <li> Formats the PEM formatted CSR as JSON string that be sent to Firefly</li> </ol>","tags":["v0.1"]},{"location":"#step-5-request-a-certificate","title":"Step 5 - Request a certificate","text":"<p>Now that we have both a JWT and a CSR we can make a request to our Firefly instance. </p> <p>The following cURL command sends a simple JSON data structure to Firefly that contains the CSR and a reference to the policy that will be used to fulfill the certificate request. The policy reference must correspond to one of the <code>venafi-firefly.allowedPolicies</code> within the JWT. </p> cURL Usage to request certificate<pre><code>curl 'https://localhost:8289/v1/certificatesigningrequest' \\\n--header 'Content-Type: application/json' \\\n -H \"Authorization: Bearer $token\" \\\n--data '{\n    \"request\": \"'\"$csr\"'\",\n    \"policyName\": \"Firefly Playground\"\n}' -k -s \n</code></pre> <p>You should see output similar to the following. Note: The response includes the following certificates which are returned in the order listed: </p> <ul> <li>The entity/leaf certificate itself </li> <li>The intermediate certificate for the <code>Firefly SubCA</code> used to sign the requested entity/leaf certificate </li> <li>The intermediate/SubCa certificate for the<code>Sub CA Provider</code> as listed in the Venafi Control plane</li> </ul> Truncated Output<pre><code>{\"certificateChain\":\"-----BEGIN CERTIFICATE-----\\nMIICgDCCAiagAwIBAgIRAPVKH ....\n</code></pre> Tip - Getting a valid PEM format <p>Because the output is returned as a JSON data structure it will be JSON encoded and the certificate chain will be on a single line. This will not work with your applications that typically require a PEM format which includes newlines. You can use the <code>JQ</code> utility to reformat the certificate chain and remove the JSON encoding. To do this pipe the output to <code>JQ</code> and specifiy the <code>-r</code> for raw flag.</p> Example<pre><code>curl --location 'https://localhost:8289/v1/certificatesigningrequest' \\\n--header 'Content-Type: application/json' \\\n -H \"Authorization: Bearer $token\" \\\n--data '{\n    \"request\": \"'\"$csr\"'\",\n    \"policyName\": \"Firefly Playground\"\n}' -k -s | jq -r .certificateChain\n</code></pre> <p>This will produce a PEM output that will probably be more useful and can be used directly by your applications. </p> Example PEM Output<pre><code>    -----BEGIN CERTIFICATE-----\nMIICgDCCAiagAwIBAgIRALcojaIkJtPIm7suinBqQPgwCgYIKoZIzj0EAwIwFjEU\nMBIGA1UEAxMLRGVtbyBJc3N1ZXIwHhcNMjQwMjEwMTEzMjAzWhcNMjQwNTEwMTEz\nMjAzWjBAMQ4wDAYDVQQHEwVTb2ZpYTEVMBMGA1UEChMMVmVuYWZpLCBJbmMuMRcw\nFQYDVQQDDA51c2VyMUBhY21lLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCC\nAQoCggEBAK1whkeg9ucVyPCB/Kyur6w3WzVepUT03tzF8GHSRbT6RXdwGPcq/ck7\nX3/D3mPuU2S3HL7FjpNIEi3pXJazjQBFxzKaKqlYorkcEs7IPwDa+xgMUubCBK7/\n1i27HmMo0yBRtrN6ulUNsuTFhXUsQpLThtOTafcGjwau7grIp9IXmYrvdkS9HQOs\nYATxN3HM9FMaUNWrF/p7iaMNSMttnLu7aGVUe5O15i1C9ixzlc4u0SU0ZR6K722z\n2EuFNQtQzsXKBobqmvMUo3Pi4HUuDQ4W79TEEBoWHdotCZY+NO153+bBCVdh/nwO\ngzkya5+atFNFdr6EetegN/yoxrb4sAUCAwEAAaNgMF4wDgYDVR0PAQH/BAQDAgWg\nMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAMBgNVHRMBAf8EAjAAMB8G\nA1UdIwQYMBaAFJZxTTv0xv8Kc2mLIjlXunAOoCiuMAoGCCqGSM49BAMCA0gAMEUC\nIQDQcZHeoZ2ngis5LAsG4cLAng+CyVYEnyCMG9/cGZdEVgIgal9HjdkasP1DeRga\nK3i8pw9dTr40mvhPVtQwYQw03cM=\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\nMIIDtTCCAp2gAwIBAgIUaafwxTAoCEc2EkPeII39lnt8y/UwDQYJKoZIhvcNAQEL\nBQAweDELMAkGA1UEBhMCVVMxFTATBgNVBAoTDFZlbmFmaSwgSW5jLjERMA8GA1UE\nCxMIQnVpbHQtaW4xPzA9BgNVBAMTNkRlZGljYXRlZCAtIFZlbmFmaSBDbG91ZCBC\ndWlsdC1JbiBJbnRlcm1lZGlhdGUgQ0EgLSBHMTAeFw0yNDAyMTAxMTExNTdaFw0y\nNDA1MTAxMTEyMjdaMBYxFDASBgNVBAMTC0RlbW8gSXNzdWVyMFkwEwYHKoZIzj0C\nAQYIKoZIzj0DAQcDQgAEresHmPd1pKTqTD5Cob8O0VVgm+3rMnJGpBRidsV2AguR\nxUFLtjq5VdWqx+RjVSHyZ6n+r1jyVPE20Q90Bo+wFqOCAWIwggFeMBIGA1UdEwEB\n/wQIMAYBAf8CAQAwHQYDVR0OBBYEFJZxTTv0xv8Kc2mLIjlXunAOoCiuMB8GA1Ud\nIwQYMBaAFCe55cW8WhjR9H0N3jhpvocPFjUCMIGCBggrBgEFBQcBAQR2MHQwcgYI\nKwYBBQUHMAKGZmh0dHA6Ly9idWlsdGluY2EudmVuYWZpLmNsb3VkL3YxL2J1aWx0\naW5jYS9jYWNoYWluLzBkNDdhNTgxLTk1OGQtMTFlZC1iN2JjLWJmZTEyYmY1ZTUx\nNi1JbnRlcm1lZGlhdGVDQTBzBgNVHR8EbDBqMGigZqBkhmJodHRwOi8vYnVpbHRp\nbmNhLnZlbmFmaS5jbG91ZC92MS9idWlsdGluY2EvY3JsLzBkNDdhNTgxLTk1OGQt\nMTFlZC1iN2JjLWJmZTEyYmY1ZTUxNi1JbnRlcm1lZGlhdGVDQTAOBgNVHQ8BAf8E\nBAMCAoQwDQYJKoZIhvcNAQELBQADggEBAHr/CzXpoq5XGWWBQIgWCka4cQKisSK5\nwJAVY771mcwxjt0kfQh7jKzI6gH/xGJIeWXIbzAnIIAMItWWNeVnCJfQD8rkDPdC\nIyrscWUzZJIxxqeNt0oV4a8qV5OAY24ODRo9vYdR1wqKE0CPAYLFAzgIZSR4aQY5\nFYMl2Hk1XoY67nYlSBLr2IcletACpHmt83GjBKyeT0VX00AEqO7Z9cDQ/Iq3qInC\ndLxuPbSd+0cPM6mQEcVrZpkzqYSWYgkIm2BdPbYyQFUnFRICC0IGzz4+xfvLppRE\nQDxLYgi8/MD8ebn9xuwZIyJZ4FgFbci49Df4qgPGgTRiE4cnED76wBc=\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\nMIIEtzCCA5+gAwIBAgIUZLSN3/h90AM/RJcoX2beeYd1vqkwDQYJKoZIhvcNAQEL\nBQAwZjELMAkGA1UEBhMCVVMxFTATBgNVBAoTDFZlbmFmaSwgSW5jLjERMA8GA1UE\nCxMIQnVpbHQtaW4xLTArBgNVBAMTJERlZGljYXRlZCAtIFZlbmFmaSBDbG91ZCBC\ndWlsdC1JbiBDQTAeFw0yMzAxMTYxMTAwMjlaFw0yODAxMTUxMTAwNTlaMHgxCzAJ\nBgNVBAYTAlVTMRUwEwYDVQQKEwxWZW5hZmksIEluYy4xETAPBgNVBAsTCEJ1aWx0\nLWluMT8wPQYDVQQDEzZEZWRpY2F0ZWQgLSBWZW5hZmkgQ2xvdWQgQnVpbHQtSW4g\nSW50ZXJtZWRpYXRlIENBIC0gRzEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK\nAoIBAQDbB2x7ti8wNQFho7BhriBfOArJnh5blnuk+M0OO3LdBNWc0C0Kw7LusPAi\njL26iliHilX9jTcmSO/8fTnHmAJp2ZgtG6BBGUX+srez1i/oyGKn4ISPpLezvawy\nqym4CBGcYkq6Ob9EaGX8kl7todPRvrkWBRQxX/iXnt1p+WBoqw3H4D/uZw1M2LRY\ngxaqTwyjotOQmsfv/nN1Ylpn5Qc3glOTcIX9ijP7EvBpwIuSGE9zpuH6d7JCaV6t\nmDr7Lk7KgCxSVaM7mBiZ3Nkf1JC+J805chUOCf4P5wOL8yGphYN8LsmpJgNw/gEo\ndwl+dt96WfW29meEWos9pVY4/Y/VAgMBAAGjggFJMIIBRTAOBgNVHQ8BAf8EBAMC\nAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJ7nlxbxaGNH0fQ3eOGm+hw8W\nNQIwHwYDVR0jBBgwFoAUxmQN0ktNODYkJmEFxskk7NhgrYowdQYIKwYBBQUHAQEE\naTBnMGUGCCsGAQUFBzAChllodHRwOi8vYnVpbHRpbmNhLnZlbmFmaS5jbG91ZC92\nMS9idWlsdGluY2EvY2EvMGQ0N2E1ODEtOTU4ZC0xMWVkLWI3YmMtYmZlMTJiZjVl\nNTE2LVJvb3RDQTBrBgNVHR8EZDBiMGCgXqBchlpodHRwOi8vYnVpbHRpbmNhLnZl\nbmFmaS5jbG91ZC92MS9idWlsdGluY2EvY3JsLzBkNDdhNTgxLTk1OGQtMTFlZC1i\nN2JjLWJmZTEyYmY1ZTUxNi1Sb290Q0EwDQYJKoZIhvcNAQELBQADggEBAJttmpUq\nEXNfl3DLfWuMaFOrLWh5B/m5bPJXGtMKzJFN3MtLjiBRz5yq5BtRf4xHbEHYGk0h\nN2jJo56zSR7H6YI0tmy/uPW0H9NNkVMBvOIX/qhOkVPWMCmJY82qI5bv4yAgClXY\nxBaA2IaATA+ZAd9IvJdyLnkKxkKz1vP2OwJ3eF3oX0gY5NnQNtXGUyAMfgyrJaCi\neKEwu5EVKVwoXYDyO3rrkKgnmzktyiKxtAij6sf3Z4CRDhrnfwGXJnv6DJHj1yFd\nLHv2Zzh0jOjXXtvwoP5pvoOTkToVsTdW+KpBowracf19pS56ZbLtOOxIxX65FpGo\nx4QlptWfjmdj2zI=\n-----END CERTIFICATE-----   \n</code></pre>","tags":["v0.1"]},{"location":"ei-quick-start/","title":"Evaluators Guide: CyberArk Enterprise Issuer","text":"","tags":["v0.3","DRAFT","In Progress"]},{"location":"ei-quick-start/#evaluators-guide-cyberark-enterprise-issuer","title":"Evaluators Guide: CyberArk Enterprise Issuer","text":"","tags":["v0.3","DRAFT","In Progress"]},{"location":"ei-quick-start/#cert-manager-cyberark-enterprise-issuer-cyberark-certificate-manager","title":"cert-manager  CyberArk Enterprise Issuer  CyberArk Certificate Manager","text":"<p>Warning</p> <p>This document is currently a working draft and assumes some knowledge of Kubernetes/OpenShift and there my some inaccuracies and errors. It is intended to provide Information Security and platform teams with a quick overview for integrating CyberArk's Workload Identity Issuer with 'cert-manager<code>and</code>Istio` service-mesh. It is NOT intended to be used for production purposes.</p> <p>Please also not that the original Venafi product names are currently transitioning to CyberArk therefore the document uses both Venafi and CyberArk interchangeably.</p>","tags":["v0.3","DRAFT","In Progress"]},{"location":"ei-quick-start/#objective","title":"Objective","text":"<ul> <li>Install CyberArk's Enterprise Issuer in a Kubernetes or OpenShift cluster using <code>helm</code></li> <li>Install CyberArk's Enterprise <code>cert-manager</code> in a Kubernetes or OpenShift cluster using <code>helm</code></li> <li>Configure CyberArk Enterprise Issuer to connect to CyberArk's SaaS or Self Hosted control planes</li> <li>Configure <code>cert-manager</code> to use CyberArk Enterprise Issuer for requesting certificates via CyberArk's SaaS or Self Hosted control planes</li> <li>Create a new certificate request resource and observe it creating a new certificate request</li> <li>View the new certificate in the Kubernetes secret store</li> </ul>","tags":["v0.3","DRAFT","In Progress"]},{"location":"ei-quick-start/#overview","title":"Overview","text":"<p>This evaluation guide is intended to to provide a single point of reference for installing and configuring CyberArk Enterprise Issuer (EI) with cert-manager. It provides the evaluator with a structured guided step by step list of tasks with explanations along the way.</p> <p>It will include the following components:</p> <ul> <li>Enterprise Issuer for CyberArk Certificate Manager: Enterprise Issuer for CyberArk Certificate Manager (formerly as Venafi Enhanced Issuer) is a cert-manager issuer that can be either cluster-wide or per namespace. This component enables your clusters to issue certificates from Venafi Control Plane.</li> <li>Venafi Connection: Venafi Connection is used to configure the connection and authentication between Venafi Control Plane and your Kubernetes cluster.</li> <li>Enterprise cert-manager: Enterprise cert-manager adds certificates and certificate issuers as resource types in Kubernetes clusters, and simplifies the process of obtaining, renewing and using certificates. Venafi provides Long-Term Support (LTS) releases of cert-manager to help organizations with lifecycle planning. Each LTS release is maintained for a minimum of two years.</li> </ul> <p>The components are stored in either a public or private repository.</p> <ul> <li>Public Registries: These are deployed in all available Venafi Control Plane regions and serve from a single location: registry.venafi.cloud. Public registries hold publicly available artifacts and do not require authentication.</li> <li>Private Registries: These registries store enterprise Venafi software and are available in region-specific locations.    US region - private-registry.venafi.cloud    EU region - private-registry.venafi.eu    Users in the US, Canada, Australia, and Singapore regions should use the US registry. Users in the EU and UK should use the EU registry.    Access to these registries requires a subscription to the Venafi Control Plane. For your convenience, the private registries also contain the public artifacts hosted by the public registries.</li> </ul> <p>There are two ways to acquire credentials to access the registry:</p> <ul> <li>Using the Venafi Control Plane UI</li> <li>Using the CLI tool for CyberArk Certificate Manager</li> </ul> <p>Users in the US, Canada, Australia, and Singapore regions should use the US registry. Users in the EU and UK should use the EU registry:</p> <ul> <li>US: oci://private-registry.venafi.cloud/</li> <li>EU: oci://private-registry.venafi.eu/</li> </ul> <p>Prerequisites</p> <p>To complete this quick-start you will need to ensure that the following utilities are installed: </p> <ul> <li><code>venctl</code> A CLI tool that enables interaction with CyberArk Certificate Manager from the command line. You can install it from here: https://docs.venafi.cloud/vaas/venctl/t-venctl-install/</li> <li><code>imgpkg</code> A CLI  tool that allows users to store a set of arbitrary files as an OCI image. You can install it from here: https://github.com/carvel-dev/imgpkg</li> <li><code>jq</code> A lightweight CLI tool and flexible command-line JSON processor. You can install it from here: https://jqlang.org</li> <li><code>cmctl</code> A command line tool that can help you manage cert-manager and its resources inside your cluster. You can install it from here: https://cert-manager.io/docs/reference/cmctl/#installation</li> </ul> Step 1. Enable access to the private CyberArk OCI registry <p>In this step we will enable access to the private CyberArk OCI (Open Container Initiative) registry which stores the enterprise container images, Helm charts, and other artifacts. To save some time we'll use the <code>venctl</code> command line to get the credential. </p> <p>A note about CyberArk OCI registries</p> <p>There are two types of registries: public and private.</p> <ul> <li>Public Registries: These are deployed in all available Venafi Control Plane regions and serve from a single location: registry.venafi.cloud. Public registries hold publicly available artifacts and do not require authentication.</li> <li> <p>Private Registries: These registries store enterprise Venafi software and are available in region-specific locations.   US region - private-registry.venafi.cloud   EU region - private-registry.venafi.eu   Users in the US, Canada, Australia, and Singapore regions should use the US registry. Users in the EU and UK should use the EU registry.   Access to these registries requires a subscription to the Venafi Control Plane. For your convenience, the private registries also contain the public artifacts hosted by the public registries.   There are two ways to acquire credentials to access the registry:</p> </li> <li> <p>Using the Venafi Control Plane UI</p> </li> <li>Using the CLI tool for CyberArk Certificate Manager</li> </ul> <p>This step also requires access to a system where jq and kubectl are installed.</p> <p>Users in the US, Canada, Australia, and Singapore regions should use the US registry. Users in the EU and UK should use the EU registry:</p> <ul> <li>US: oci://private-registry.venafi.cloud/</li> <li>EU: oci://private-registry.venafi.eu/     </li> </ul> <p>a. Create an \"image pull\" credential</p> Command: Create an image pull credential<pre><code>venctl iam service-accounts registry create --name \"Enterprise Image Pull Secret\" \\  # (1)\n  --scopes cert-manager-components,enterprise-venafi-issuer,enterprise-approver-policy,openshift-routes \\\n  --output dockerconfig \\\n  --output-file venafi_registry_docker_config.json \\  # (2)\n  --validity 365 \\\n  --api-key {API_KEY}  # (3)\n</code></pre> <ol> <li> This is the display name for the credential listed in the SaaS control plane under \"Service accounts\"</li> <li> This is the file name that will be used to store the new credential\"</li> <li> This is API key used to authenticate with the SaaS control plane under \"Account, Preferences\"    </li> </ol> <p>We now have three options for pulling images from the private repository. We can configure Kubernetes (option 1) to use the \"image pull\" credential so that it can directly pull images from the private repository. However, some orgnizations require helm charts and images to be pulled down and added \"mirrored\" (option 2) to their own private repositories. Alternatively, the charts and images can be downloaded (option 3) manually. </p>  Option 1 - Kubernetes pulls Option 2 - Mirror the repository Option 3 - Manual download <p>This option will create a new \"image pull\" secret in Kubernetes that will enable Kubernetes to pull the CyberArk Enterprise components directly from the private repo   </p> <p>a. Create a new secret from the credential</p> Command: Create secret for image-pull<pre><code>kubectl create namespace venafi\nkubectl create secret docker-registry venafi-image-pull-secret --namespace venafi --from-file .dockerconfigjson=venafi_registry_docker_config.json\n</code></pre> <p>b. Inspect the secret</p> Command: Get secret<pre><code>kubectl get secret venafi-image-pull-secret --namespace venafi \\\n  --output=\"jsonpath={.data.\\.dockerconfigjson}\" \\\n  | base64 --decode \\\n  | jq\n</code></pre> <p>To set up Docker mirroring, follow the specific process for your mirroring tool, like Artifactory.</p> <p>The username and password can be extracted from the \"image pull\" credential from above using the following command:</p> command<pre><code>cat venafi_registry_docker_config.json \\\n| jq '.. | select(.username?) | \"username: \\(.username)\\npassword: \\(.auth)\"' -r\n</code></pre> <p>We'll use this option to download the helm charts and images for cert-manager and the Enterprise issuer using the <code>imgpkg</code> CLI utility. </p> <p>A note about imgpkg</p> <p><code>imgpkg</code> is a tool that allows users to store a set of arbitrary files as an OCI image. One of the driving use cases is to store Kubernetes configuration (plain YAML, ytt templates, Helm templates, etc.) in OCI registry as an image.</p> <p>You can install it from here: https://github.com/carvel-dev/imgpkg</p> <p>a. Extract the username and password</p> Command<pre><code>cat venafi_registry_docker_config.json \\\njq '.. | select(.username?) | \"username: \\(.username)\\npassword: \\(.auth)\"' -r\n</code></pre> <p>b. Login to the private repo using the username/password extracted from the above command,</p> command<pre><code>docker login private-registry.venafi.cloud \\\n--username $(cat venafi_registry_docker_config.json | jq '.. | select(.username?).username' -r) \\\n--password $(cat venafi_registry_docker_config.json | jq '.. | select(.username?).auth | @base64d' -r | cut -d: -f2)\n</code></pre> <p>c. Download the Enterprise Issuer image and helm chart</p> command<pre><code>imgpkg copy --image private-registry.venafi.cloud/venafi-issuer/venafi-enhanced-issuer:v0.16.0 --to-tar venafi-enhanced-issuer-v0.16.0.tar\nimgpkg copy --image private-registry.venafi.cloud/charts/venafi-enhanced-issuer:v0.16.0 --to-tar venafi-enhanced-issuer-helm-v0.16.0.tar\n</code></pre> <p>d. Download cert-manger images and helm chart</p> <p></p>command<pre><code>imgpkg copy --image private-registry.venafi.cloud/cert-manager/cert-manager-controller:v1.18.2 --to-tar cert-manager-controller-v1.18.2.tar\nimgpkg copy --image private-registry.venafi.cloud/cert-manager/cert-manager-acmesolver:v1.18.2 --to-tar cert-manager-acmesolver-v1.18.2.tar\nimgpkg copy --image private-registry.venafi.cloud/cert-manager/cert-manager-cainjector:v1.18.2 --to-tar cert-manager-cainjector-v1.18.2.tar\nimgpkg copy --image private-registry.venafi.cloud/cert-manager/cert-manager-webhook:v1.18.2 --to-tar cert-manager-webhook-v1.18.2.tar\nimgpkg copy --image private-registry.venafi.cloud/cert-manager/cert-manager-startupapicheck:v1.18.2 --to-tar cert-manager-startupapicheck-v1.18.2.tar\nimgpkg copy --image private-registry.venafi.cloud/charts/cert-manager:v1.18.2 --to-tar cert-manager-helm-v1.18.2.tar\n</code></pre> e. Publish the Enterprise Issuer image and chart to your own repository<p></p> <p></p>command<pre><code>imgpkg copy --tar venafi-enhanced-issuer-v0.16.0.tar --to-repo myrepo/venafi-enhanced-issuer\nimgpkg copy --tar venafi-enhanced-issuer-helm-v0.16.0.tar --to-repo myrepo/venafi-enhanced-issuer\n</code></pre> f. Publish the cert-manger images and charts to your own repository<p></p> command<pre><code>imgpkg copy --tar cert-manager-controller-v1.18.2.tar --to-repo myrepo/cert-manager-controller\nimgpkg copy --tar cert-manager-acmesolver-v1.18.2.tar --to-repo myrepo/cert-manager-acmesolver\nimgpkg copy --tar cert-manager-cainjector-v1.18.2.tar --to-repo myrepo/cert-manager-cainjector\nimgpkg copy --tar cert-manager-webhook-v1.18.2.tar --to-repo myrepo/cert-manager-webhook\nimgpkg copy --tar cert-manager-startupapicheck-v1.18.2.tar --to-repo myrepo/cert-manager-startupapicheck \nimgpkg copy --tar cert-manager-helm-v1.18.2.tar --to-repo myrepo/cert-manager \n</code></pre> Step 2. Install and configure cert-manager <p>Use the following <code>helm</code> command to install <code>cert-manager</code> from the CyberArk OCI image registry.</p> Command: cert-manager install<pre><code>helm upgrade cert-manager oci://registry.venafi.cloud/charts/cert-manager \\ # (1)\n  --install \\\n  --wait \\\n  --create-namespace \\\n  --namespace venafi \\\n  --values cert-manager.values.yaml \\  # (2)\n  --version v1.18.2\n</code></pre> <ol> <li> Replace with your own private repo if required.</li> <li> Use the <code>cert-manager.values.yaml</code> provided below.</li> </ol> <p>Use the following YAML to provide the values to helm.</p> cert-manager.values.yaml<pre><code>global:\n  imagePullSecrets:\n    - name: venafi-image-pull-secret  # (1)\n\ncrds:\n  enabled: true\n\nimage:\n  repository: private-registry.venafi.cloud/cert-manager/cert-manager-controller\n\nacmesolver:\n  image:\n    repository: private-registry.venafi.cloud/cert-manager/cert-manager-acmesolver\n\nwebhook:\n  image:\n    repository: private-registry.venafi.cloud/cert-manager/cert-manager-webhook\n\ncainjector:\n  image:\n    repository: private-registry.venafi.cloud/cert-manager/cert-manager-cainjector\n\nstartupapicheck:\n  image:\n    repository: private-registry.venafi.cloud/cert-manager/cert-manager-startupapicheck\n</code></pre> <ol> <li> This is the name of the Kubernetes secret you created in step 1 above.</li> </ol> Step 3. Install Enterprise issuer <p>Use the following <code>helm</code> command to install <code>enterprise issuer</code> from the CyberArk OCI image registry.</p> Command: Enterprise Issuer install<pre><code>helm upgrade venafi-enhanced-issuer oci://registry.venafi.cloud/charts/venafi-enhanced-issuer \\\n    --install \\\n    --wait \\\n    --namespace venafi \\\n    --values venafi-enhanced-issuer.values.yaml \\ # (1)\n    --version v0.16.0\n</code></pre> <ol> <li> Use the <code>venafi-enhanced-issuer.values.yaml</code> provided below.</li> </ol> venafi-enhanced-issuer.values.yaml<pre><code>global:\n  imagePullSecrets:\n    - name: venafi-image-pull-secret  # (1)\n\nvenafiConnection:\n  include: true # set to `false` if Venafi Connection CRDs &amp; RBAC are already installed\n\nvenafiEnhancedIssuer:\n  manager:\n    image:\n      repository: private-registry.venafi.cloud/venafi-issuer/venafi-enhanced-issuer\n</code></pre> <ol> <li> This is the name of the Kubernetes secret you created in step 1 above.</li> </ol> <p>Note</p> <p>The enterprise issuer will automatically install the `Venafi Connection\" component. Venafi Connection is used to configure the connection and authentication between Venafi Control Plane and your Kubernetes cluster.</p> <p>Venafi Connection is a \"namespaced\" resource. Any service account or secret referenced by a Venafi Connection must be in the same namespace as the Venafi Connection resource or in a namespace that matches the allowReferencesFrom field, as described in cross namespace Venafi Connection references.</p> <p>You can add the custom resources definitions for Venafi Connections to your Kubernetes API server when you install one of the projects that use the Venafi Connection resources as configuration.</p> Step 4. Venafi Connections <p>The custom resources definitions for VenafiIssuer and VenafiClusterIssuer are added to your Kubernetes API server when you install Enterprise Issuer.</p> <p>Select one of the following: </p> Venafi SaaS ConnectionVenafi TPP Connection <p>VenafiClusterIssuer is a cluster-scoped resource and doesn't have a namespace. Any Venafi Connection custom resource referenced by a VenafiClusterIssuer MUST be in the venafi namespace, or which ever namespace you installed Enterprise Issuer in.</p> <p>Todo</p> <p>create a secret</p> create SaaS secret<pre><code>#title=\"venafi-cloud-credentials secret\"\nkubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: venafi-cloud-credentials\n  namespace: venafi\nstringData:\n  venafi-cloud-key: $(API_KEY)\nEOF\n</code></pre> <p>create a SaaS connection</p> create VenafiConnection<pre><code>#title=\"Create VenafiConnection\"\n# Create a Venafi Connection that uses the above credential\nkubectl apply -f - &lt;&lt;EOF\napiVersion: jetstack.io/v1alpha1\nkind: VenafiConnection\nmetadata:\n  name: venafi-saas-connection\n  namespace: venafi\nspec:\n  vaas:\n    url: https://api.venafi.cloud\n    apiKey:\n    - secret:\n        name: venafi-cloud-credentials\n        fields: [\"venafi-cloud-key\"]\nEOF\n</code></pre> <p>Inspect the connection</p> Command: get venafiConnection<pre><code> kubectl get venafiConnection -n venafi\n</code></pre> Output: get venafiConnection<pre><code>NAME                     AGE\nvenafi-saas-connection   5d22h\n</code></pre> <p>Create a cluster role</p> Create ClusterRole &amp; ClusterRoleBinding<pre><code># create role that allows creating sa tokens for 'sandbox'\nkubectl apply -f - &lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: read-creds-secret-role-for-venafi-connection\nrules:\n- apiGroups: [\"\"]\n  resources:\n  - secrets\n  verbs:\n  - get\n  resourceNames: [ \"venafi-cloud-credentials\" ]\n---\n# link the controller's service account to the 'create-tokens-for-vault-sa' role\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: read-creds-secret-role-for-venafi-connection\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: read-creds-secret-role-for-venafi-connection\nsubjects:\n- kind: ServiceAccount\n  name: venafi-connection\n  namespace: venafi\nEOF\n</code></pre> <p>VenafiIssuer is a \"namespaced\" resource. Any Venafi Connection custom resource referenced by a VenafiIssuer MUST be in the same namespace as the VenafiIssuer resource or MUST be in a namespace explicitly allowed in the Venafi Connection CR definition.</p> <p>Todo</p> <p>get an access token with VCert</p> get access token<pre><code>vcert getcred -u \"https://tpp.emea.venafidemo.com\" --username carl --password Tdoxwg7HysJOACvT\n</code></pre> <p>create a TPP secret </p> create TPP secret<pre><code>#title=\"venafi-cloud-credentials secret\"\nkubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: venafi-tpp-credentials\n  namespace: venafi\nstringData:\n  access-token: tuGwRpdwS580UvoTSOfORA==\nEOF\n</code></pre> <p>create a TPP connection</p> create VenafiIssuer<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: jetstack.io/v1alpha1\nkind: VenafiConnection\nmetadata:\n  name: venafi-tpp-connection\n  namespace: venafi\nspec:\n  tpp:\n    url: https://tpp.emea.venafidemo.com\n    accessToken:\n    - secret:\n        name: venafi-tpp-credentials\n        fields: [\"access-token\"]\nEOF\n</code></pre> <p>Inspect the connection</p> Command: get venafiConnection<pre><code> kubectl get venafiConnection -n venafi\n</code></pre> Output: get venafiConnection<pre><code>NAME                     AGE\nvenafi-tpp-connection    5d23h\n</code></pre> <p>Create a cluster role</p> Create ClusterRole &amp; ClusterRoleBinding<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: read-creds-secret-role-for-venafi-tpp-connection\nrules:\n- apiGroups: [\"\"]\n  resources:\n  - secrets\n  verbs:\n  - get\n  resourceNames: [ \"venafi-tpp-credentials\" ]\n---\n# link the controller's service account to the 'create-tokens-for-vault-sa' role\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: read-creds-secret-role-for-venafi-tpp-connection\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: read-creds-secret-role-for-venafi-tpp-connection\nsubjects:\n- kind: ServiceAccount\n  name: venafi-connection\n  namespace: venafi\nEOF\n</code></pre> Step 5. Creating a cluster issuers <p>Enterprise Issuer for CyberArk Certificate Manager (formally Enterprise Issuer) has two custom resources: <code>VenafiIssuer</code> and <code>VenafiClusterIssuer</code>.</p> <p>The custom resources definitions for VenafiIssuer and VenafiClusterIssuer are added to your Kubernetes API server when you install Enterprise Issuer.</p> <p>Select one of the following: </p> VenafiClusterIssuerVenafiIssuer <p>VenafiClusterIssuer is a cluster-scoped resource and doesn't have a namespace. Any Venafi Connection custom resource referenced by a VenafiClusterIssuer MUST be in the venafi namespace, or which ever namespace you installed Enterprise Issuer in.</p> <p>The example below assumes that the following Venafi Connection resource exists:</p> create VenafiClusterIssuer<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: jetstack.io/v1alpha1\nkind: VenafiClusterIssuer\nmetadata:\n  name: venafi-tpp-cluster-issuer\nspec:\n  venafiConnectionName: venafi-tpp-connection\n  zone: cert-manager\\\\demo\nEOF\n</code></pre> <p>VenafiIssuer is a \"namespaced\" resource. Any Venafi Connection custom resource referenced by a VenafiIssuer MUST be in the same namespace as the VenafiIssuer resource or MUST be in a namespace explicitly allowed in the Venafi Connection CR definition.</p> <p>The example below assumes that the following Venafi Connection resource exists:</p> create VenafiIssuer<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: jetstack.io/v1alpha1\nkind: VenafiIssuer\nmetadata:\n  name: venafi-tpp-issuer\n  namespace: application-team-1\nspec:\n  venafiConnectionName: venafi-tpp-connection\n  zone: \\VED\\Policy\\Teams\\application-team-1\\ingress-certs\nEOF  \n</code></pre> Step 6. Configure an RBAC for cert-manager auto-approve <p>If you are using Approver Policy or Enterprise Approver Policy for CyberArk Certificate Manager, no further action is required. If not, you must let cert-manager auto-approve the certificate requests that reference the VenafiClusterIssuer and VenafiIssuer types with the following RBAC</p> <pre><code># Configure cert-manager approval \nkubectl apply -f - &lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: cert-manager-controller-approve:venafi-enhanced-issuer\nrules:\n  - apiGroups: [\"cert-manager.io\"]\n    resources: [\"signers\"]\n    verbs: [\"approve\"]\n    resourceNames: [\"venafiissuers.jetstack.io/*\", \"venaficlusterissuers.jetstack.io/*\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: cert-manager-controller-approve:venafi-enhanced-issuer\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: cert-manager-controller-approve:venafi-enhanced-issuer\nsubjects:\n  - name: cert-manager\n    namespace: venafi\n    kind: ServiceAccount\nEOF\n</code></pre> <p>Check the cluster issuer</p> <pre><code>kubectl get Venaficlusterissuers -n venafi\n</code></pre> Step 7. Creating a testing certificate resources Using venafi-saas-cluster-issuerUsing venafi-tpp-cluster-issuer <p>Create a new Certificate</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\nkind: Certificate\napiVersion: cert-manager.io/v1\nmetadata:\n  name: venafi-saas-test-1\n  namespace: venafi\nspec:\n  secretName: venafi-saas-test-1\n  commonName: srvc2.acme.com\n  issuerRef:\n    name: venafi-saas-cluster-issuer\n    kind: \"VenafiClusterIssuer\"\n    group: \"jetstack.io\"\n  privateKey:\n    rotationPolicy: Always\n    size: 2048\n  dnsNames:\n  - srvc3.acme.com\n  #uris:\n  #- spiffe://cluster.local/ns/sandbox/sa/srvc1\nEOF\n</code></pre> <p>Create a new Certificate</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\nkind: Certificate\napiVersion: cert-manager.io/v1\nmetadata:\n  name: venafi-tpp-test-1\n  namespace: venafi\nspec:\n  secretName: venafi-tpp-test-1\n  commonName: srvc2.acme.com\n  issuerRef:\n    name: venafi-tpp-cluster-issuer\n    kind: \"VenafiClusterIssuer\"\n    group: \"jetstack.io\"\n  privateKey:\n    rotationPolicy: Always\n    size: 2048\n  dnsNames:\n  - srvc3.acme.com\n  #uris:\n  #- spiffe://cluster.local/ns/sandbox/sa/srvc1\nEOF\n</code></pre> Step 8. Securing an NGINX Ingress <p>There are two primary ways to secure an NGINX ingress resource: using annotations on the ingress with ingress-shim or directly creating a certificate resource.</p> <p>In this example, we will add annotations to the ingress, and take advantage of ingress-shim to have it create the certificate resource on our behalf. </p> <p>Now lets secure an NGINX ingress. For this demo we'll use the example kuard application.</p> <p>First we'll create a deployment</p> <p></p>Create a deployment<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: kuard\nspec:\n  selector:\n    matchLabels:\n      app: kuard\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: kuard\n    spec:\n      containers:\n      - image: gcr.io/kuar-demo/kuard-amd64:1\n        imagePullPolicy: Always\n        name: kuard\n        ports:\n        - containerPort: 8080\n  EOF\n</code></pre> Now lets create a service <p></p> Create the an service<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Service\nmetadata:\n  name: kuard\nspec:\n  ports:\n  - port: 80\n    targetPort: 8080\n    protocol: TCP\n  selector:\n    app: kuard\nEOF\n</code></pre> <p>Finally lets create an ingress that uses the <code>venafi-saas-cluster-issuer</code> to get a certificate. </p> Create the an NGINX ingress<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: kuard\n  annotations:\n    cert-manager.io/issuer: venafi-saas-cluster-issuer\n    cert-manager.io/issuer-kind: VenafiClusterIssuer \n    cert-manager.io/issuer-group: jetstack.io\n    cert-manager.io/common-name: example.example.com\nspec:\n  ingressClassName: nginx\n  tls:\n  - hosts:\n    - example.example.com\n    secretName: example.example.com-tls\n  rules:\n  - host: example.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: kuard\n            port:\n              number: 80\nEOF\n</code></pre> <p>Inspect the certificate</p> Create the an NGINX ingress<pre><code>kubectl get secret example.example.com-tls -o json | jq -r '.data.\"tls.crt\"' | base64 -d | certigo dump\n</code></pre> Step 9. Access to out of tree issuers <p>This section covers configuring an \"out-of-tree\" VenafiIssuer that can be access from another namespace. </p> <p>a. Create Environment Variables</p> <p>The a only for testing the out-of-tree VenafiIssuer.</p> Command<pre><code>export CERT_SUFFIX=\"$(date +%S%H%M%d%m)\"\nexport CERT_NAME=cert-${CERT_SUFFIX}.svc.cluster.local\nexport CERT_ZONE=\"cert-manager\\\\demo\"\nexport CCM_APIKEY=\"REPLACE_WITH_API_KEY\"\nexport CCM_NAMESPACE=\"venafi\"\nexport CERT_NAMESPACE=\"foo\"\n</code></pre> <p>b. Create a new VenafiConnection resource</p> Command<pre><code># create venafi connection resource \nkubectl apply -f - &lt;&lt;EOF\napiVersion: jetstack.io/v1alpha1\nkind: VenafiConnection\nmetadata:\n  name: venafi-saas-connection-for-nginx\n  namespace: ${CCM_NAMESPACE}\nspec:\n  allowReferencesFrom:\n    matchLabels:\n      kubernetes.io/metadata.name: ${CERT_NAMESPACE}\n  vaas:\n    url: https://api.venafi.cloud\n    apiKey:\n    - secret:\n        name: venafi-cloud-credentials\n        fields: [\"venafi-cloud-key\"]\nEOF\n</code></pre> <p>c. Check the VenafiConnection</p> Command<pre><code>kubectl get VenafiConnection -n venafi\n</code></pre> <p>d. Create cluster role and binding</p> Command<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: read-ccm-credentials\n  namespace: ${CCM_NAMESPACE}\nrules:\n- apiGroups: [\"\"]\n  resources: [\"secrets\"]\n  resourceNames: [\"venafi-cloud-credentials\"]\n  verbs: [\"get\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: read-ccm-credentials\n  namespace: ${CCM_NAMESPACE}\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: read-ccm-credentials\nsubjects:\n- kind: ServiceAccount\n  name: venafi-connection\n  namespace: ${CCM_NAMESPACE}\nEOF\n</code></pre> <p>e. Create a test namespace</p> Command<pre><code>kubectl create namespace ${CERT_NAMESPACE}\n</code></pre> <p>f. Create a VenafiIssuer in the test namespace</p> Command<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: jetstack.io/v1alpha1\nkind: VenafiIssuer\nmetadata:\n  name: venafi-saas-issuer-for-nginx\n  namespace: ${CERT_NAMESPACE}\nspec:\n  venafiConnectionName: venafi-saas-connection-for-nginx\n  venafiConnectionNamespace: ${CCM_NAMESPACE}\n  zone: ${CERT_ZONE}\nEOF    \n</code></pre> <p>g. Create a Certificate resource</p> <p>This is a test certificate only used to test the out-of-tree VenafiConnection</p> Command<pre><code>kubectl apply -f - &lt;&lt;EOF\nkind: Certificate\napiVersion: cert-manager.io/v1\nmetadata:\n  name: ${CERT_NAME}\n  namespace: ${CERT_NAMESPACE}\nspec:\n  secretName: ${CERT_NAME}\n  commonName: ${CERT_NAME}\n  duration: 24h\n  renewBefore: 8h\n  issuerRef:\n    name: venafi-saas-issuer-for-nginx\n    kind: \"VenafiIssuer\"\n    group: \"jetstack.io\"\n  privateKey:\n    rotationPolicy: Always\n    size: 2048\n  dnsNames:\n  - ${CERT_NAME}\n  #uris:\n  #- spiffe://cluster.local/ns/sandbox/sa/srvc1\nEOF\n</code></pre> <p>h. Validate the certificate is ready</p> <p>Use the following command to check that the certificate reaches the ready state. </p> Command<pre><code>echo \"Waiting up to 30s for Certificate ${CERT_NAME} in ns ${CERT_NAMESPACE} to be Ready...\"\nfor i in {1..30}; do\n  READY=$(kubectl -n \"${CERT_NAMESPACE}\" get certificate \"${CERT_NAME}\" \\\n    -o jsonpath='{.status.conditions[?(@.type==\"Ready\")].status}' 2&gt;/dev/null || true)\n\n  if [[ \"${READY}\" == \"True\" ]]; then\n    echo \"#################################################\"\n    echo \"Certificate ${CERT_NAME} is Ready\"\n    echo \"#################################################\" \n    exit 0\n  fi\n  sleep 1\ndone\n\necho \"Certificate ${CERT_NAME} not Ready after 30s\"\necho \"Troubleshoot with:\"\necho \"  kubectl -n ${CERT_NAMESPACE} describe certificate ${CERT_NAME}\"\necho \"  kubectl -n ${CERT_NAMESPACE} describe certificaterequest -l cert-manager.io/certificate-name=${CERT_NAME}\"\n</code></pre> <p>i. Update the VirtualServer config to include</p> <pre><code>tls:\n  secret: my-secret-tls\n  cert-manager:\n    issuer: venafi-saas-issuer\n    issuer-kind: VenafiIssuer\n    issuer-group: jetstack.io\n    common-name: my-secret.example.com\n    duration: 720h\n    renew-before: 480h\n    usages: digital signature,server auth,client auth\n</code></pre>","tags":["v0.3","DRAFT","In Progress"]},{"location":"istio-firefly/","title":"Firefly with Istio demo steps","text":"","tags":["v0.1","DRAFT","In Progress"]},{"location":"istio-firefly/#firefly-with-istio-demo-steps","title":"Firefly with Istio demo steps","text":"<p>This document can be used as quick evaluation guide that showcases how CyberArk WorkLoad Identity Issuer easily integrates with Istio service-mesh. </p> <p>Warning</p> <p>This document is currently a working draft and assumes some knowledge of Kubernetes. There my some inaccuracies and errors. It is intended to provide Information Security and platform teams with a quick overview for integrating CyberArk's Workload Identitiy Issuer with 'cert-manager<code>and</code>Istio` service-mesh. It is NOT intended to be used for production purposes.</p> <pre><code>kubectl config use-context kind-demo-cluster-istio-doc-testing\nkubectl config get-contexts\n</code></pre>","tags":["v0.1","DRAFT","In Progress"]},{"location":"istio-firefly/#architecture","title":"Architecture","text":"<p>Prerequisites</p> <p>To complete this quick-start you will need to ensure that the following utilities are installed: </p> <ul> <li><code>venctl</code> A CLI tool that enables interaction with CyberArk Certificate Manager from the command line. You can install it from here: https://docs.venafi.cloud/vaas/venctl/t-venctl-install/</li> <li><code>jq</code> A lightweight CLI tool and flexible command-line JSON processor. You can install it from here: https://jqlang.org</li> <li><code>cmctl</code> A command line tool that can help you manage cert-manager and its resources inside your cluster. You can install it from here: https://cert-manager.io/docs/reference/cmctl/#installation</li> </ul> <p>Lets create a new Kubernetes cluster. You can use KIND.</p>","tags":["v0.1","DRAFT","In Progress"]},{"location":"istio-firefly/#step-1-create-the-cluster-optional","title":"Step 1. Create the cluster (Optional)","text":"<pre><code>kind create cluster --name kind-demo-cluster-istio-demo \n</code></pre>","tags":["v0.1","DRAFT","In Progress"]},{"location":"istio-firefly/#step-2-get-cluster-information-optional","title":"Step 2. Get cluster information (Optional)","text":"<pre><code>kubectl cluster-info\n</code></pre>","tags":["v0.1","DRAFT","In Progress"]},{"location":"istio-firefly/#step-3-install-cert-manager","title":"Step 3. Install cert-manager","text":"<pre><code># Install cert-manager\nkubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.12.0/cert-manager.yaml\n</code></pre>","tags":["v0.1","DRAFT","In Progress"]},{"location":"istio-firefly/#step-4-create-a-new-venafi-namespace","title":"Step 4. Create a new Venafi namespace","text":"<pre><code># Create Venafi namespace\nkubectl create ns venafi\n</code></pre>","tags":["v0.1","DRAFT","In Progress"]},{"location":"istio-firefly/#step-5-get-the-trust-bundle-and-store-it-as-a-kubernetes-generic-secret","title":"Step 5. Get the trust bundle and store it as a Kubernetes generic secret","text":"<p>Login in to your're ZTPKI instance and get download the PEM chain for your CA.</p> <pre><code>kubectl create secret generic -n cert-manager root-cert --from-file={replace with pem chain filename} \n</code></pre>","tags":["v0.1","DRAFT","In Progress"]},{"location":"istio-firefly/#step-6-get-an-api-key-and-create-an-environment-variable","title":"Step 6 Get an API Key and create an environment variable","text":"<pre><code>export API_KEY= {paste api key from above}\n</code></pre>","tags":["v0.1","DRAFT","In Progress"]},{"location":"istio-firefly/#step-7-create-a-new-venafi-service-account","title":"Step 7. Create a new Venafi Service Account","text":"<pre><code>$(venctl iam service-accounts firefly create --name sa-firefly-1 --api-key $API_KEY --output json --output-file venafi-sa-creds.json  )\n</code></pre>","tags":["v0.1","DRAFT","In Progress"]},{"location":"istio-firefly/#step-8-create-a-new-firefly-configuration","title":"Step 8 Create a new Firefly configuration","text":"","tags":["v0.1","DRAFT","In Progress"]},{"location":"istio-firefly/#step-9-store-the-private-key-for-the-tlspc-service-account-as-a-generic-secret","title":"Step 9. Store the private key for the TLSPC service account as a generic secret","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: venafi-credentials\n  namespace: venafi\ntype: Generic\nstringData: \n  svc-acct.key: $(cat venafi-sa-creds.json | jq '.. | select(.private_key?).private_key')\nEOF\n</code></pre>","tags":["v0.1","DRAFT","In Progress"]},{"location":"istio-firefly/#step-10-install-firefly-using-a-helm-chart","title":"Step 10.  Install Firefly using a Helm chart","text":"<pre><code>helm upgrade prod oci://registry.venafi.cloud/public/venafi-images/helm/firefly \\\n  --set-string deployment.venafiClientID=$(cat venafi-sa-creds.json | jq '.. | select(.client_id?).client_id') \\\n  --install \\\n  --create-namespace \\\n  --namespace venafi \\\n  --values firefly-values.yaml \\\n  --version v1.5.1\n</code></pre>","tags":["v0.1","DRAFT","In Progress"]},{"location":"istio-firefly/#step-11-test-firefly-using-the-cmctl-command-line","title":"Step 11. Test Firefly using the cmctl command line","text":"<pre><code>cmctl create certificaterequest my-cr-test1 --from-certificate-file - --fetch-certificate  &lt;&lt;EOF\n  kind: Certificate\n  apiVersion: cert-manager.io/v1\n  metadata:\n    annotations:\n      #firefly.venafi.com/policy-name: istio-mtls-certs\n      firefly.venafi.com/policy-name: Firefly Playground\n  spec:\n    secretName: example-com-tls\n    commonName: srvc.acme.com\n    issuerRef:\n      name: firefly\n      kind: Issuer\n      group: firefly.venafi.com\nEOF\n</code></pre>","tags":["v0.1","DRAFT","In Progress"]},{"location":"istio-firefly/#step-12-create-a-new-namespace-for-istio","title":"Step 12. Create a new namespace for Istio","text":"<pre><code>kubectl create ns istio-system\n</code></pre>","tags":["v0.1","DRAFT","In Progress"]},{"location":"istio-firefly/#step-13-install-istio-csr-using-helm","title":"Step 13. Install Istio-CSR using Helm","text":"<pre><code>helm upgrade -i -n cert-manager cert-manager-istio-csr jetstack/cert-manager-istio-csr -f - &lt;&lt;EOF\nreplicaCount: 3\nimage:\n  repository: quay.io/jetstack/cert-manager-istio-csr\n  tag: v0.14.0\n  pullPolicy: IfNotPresent\napp:\n  certmanager:\n    namespace: istio-system\n    preserveCertificateRequests: true\n    additionalAnnotations:\n    - name: firefly.venafi.com/policy-name\n      value: istio-mtls-certs\n    issuer:\n      group: firefly.venafi.com\n      kind: Issuer\n      name: firefly-istio\n  tls:\n    trustDomain: cluster.local\n    certificateDNSNames:\n    # Name used by the e2e client\n    - istio-csr.cert-manager.svc\n    # Name used within the demo cluster\n    - cert-manager-istio-csr.cert-manager.svc\n    rootCAFile: /etc/tls/root-cert.pem\n  server:\n    maxCertificateDuration: 1440m\n    serving:\n      address: 0.0.0.0\n      port: 6443\n# -- Optional extra volumes. Useful for mounting custom root CAs\nvolumes:\n- name: root-ca\n  secret:\n    secretName: root-cert\n\n# -- Optional extra volume mounts. Useful for mounting custom root CAs\nvolumeMounts:\n- name: root-ca\n  mountPath: /etc/tls\nEOF\n</code></pre>","tags":["v0.1","DRAFT","In Progress"]},{"location":"istio-firefly/#step-14-install-istio","title":"Step 14. Install Istio","text":"<pre><code>istioctl install -y -f - &lt;&lt;EOF\n# istio-config.yaml\napiVersion: install.istio.io/v1alpha1\nkind: IstioOperator\nmetadata:\n  namespace: istio-system\nspec:\n  profile: \"demo\"\n  hub: gcr.io/istio-release\n  meshConfig:\n    # Change the following line to configure the trust domain of the Istio cluster.\n    trustDomain: cluster.local\n  values:\n    global:\n      # Change certificate provider to cert-manager istio agent for istio agent\n      caAddress: cert-manager-istio-csr.cert-manager.svc:443\n  components:\n    pilot:\n      k8s:\n        env:\n          # Disable istiod CA Sever functionality\n        - name: ENABLE_CA_SERVER\n          value: \"false\"\n        overlays:\n        - apiVersion: apps/v1\n          kind: Deployment\n          name: istiod\n          patches:\n\n            # Mount istiod serving and webhook certificate from Secret mount\n          - path: spec.template.spec.containers.[name:discovery].args[-1]\n            value: \"--tlsCertFile=/etc/cert-manager/tls/tls.crt\"\n          - path: spec.template.spec.containers.[name:discovery].args[-1]\n            value: \"--tlsKeyFile=/etc/cert-manager/tls/tls.key\"\n          - path: spec.template.spec.containers.[name:discovery].args[-1]\n            value: \"--caCertFile=/etc/cert-manager/ca/root-cert.pem\"\n\n          - path: spec.template.spec.containers.[name:discovery].volumeMounts[-1]\n            value:\n              name: cert-manager\n              mountPath: \"/etc/cert-manager/tls\"\n              readOnly: true\n          - path: spec.template.spec.containers.[name:discovery].volumeMounts[-1]\n            value:\n              name: ca-root-cert\n              mountPath: \"/etc/cert-manager/ca\"\n              readOnly: true\n\n          - path: spec.template.spec.volumes[-1]\n            value:\n              name: cert-manager\n              secret:\n                secretName: istiod-tls\n          - path: spec.template.spec.volumes[-1]\n            value:\n              name: ca-root-cert\n              configMap:\n                defaultMode: 420\n                name: istio-ca-root-cert\nEOF\n</code></pre>","tags":["v0.1","DRAFT","In Progress"]},{"location":"istio-firefly/#step-15-create-a-namespace-and-enable-side-car-injection","title":"Step 15. Create a namespace and enable side-car injection","text":"<pre><code>kubectl create ns bar\nkubectl label namespace bar istio-injection=enabled\n</code></pre>","tags":["v0.1","DRAFT","In Progress"]},{"location":"istio-firefly/#step-16-install-a-demo-app","title":"Step 16. Install a demo App","text":"<pre><code>echo \"apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: httpbin\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: httpbin\n  labels:\n    app: httpbin\n    service: httpbin\nspec:\n  ports:\n  - name: http\n    port: 8000\n    targetPort: 8080\n  selector:\n    app: httpbin\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: httpbin\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: httpbin\n      version: v1\n  template:\n    metadata:\n      labels:\n        app: httpbin\n        version: v1\n    spec:\n      serviceAccountName: httpbin\n      containers:\n      - image: docker.io/mccutchen/go-httpbin:v2.15.0\n        imagePullPolicy: IfNotPresent\n        name: httpbin\n        ports:\n        - containerPort: 8080\" &gt; httpbin.yaml \nkubectl apply -n bar -f &lt;(istioctl kube-inject -f httpbin.yaml ) \n</code></pre>","tags":["v0.1","DRAFT","In Progress"]},{"location":"istio-firefly/#step-17-inspect-the-secret","title":"Step 17. Inspect the Secret","text":"<pre><code>istioctl pc secret  $(kubectl get pod -n bar -l app=httpbin -o jsonpath={.items..metadata.name}) \\\n    -n bar -o json | \\\n    jq -r '.dynamicActiveSecrets[0].secret.tlsCertificate.certificateChain.inlineBytes' | \\\n    base64 --decode\n</code></pre>","tags":["v0.1","DRAFT","In Progress"]},{"location":"os-quick-start/","title":"OpenShift cert-manager + CyberArk Workload Identity Issuer","text":"","tags":["v0.1","DRAFT","In Progress"]},{"location":"os-quick-start/#openshift-cert-manager-cyberark-workload-identity-issuer","title":"OpenShift cert-manager + CyberArk Workload Identity Issuer","text":"<p>Warning</p> <p>This document is currently a working draft and assumes some knowledge of Kubernetes/OpenShift and there my some inaccuracies and errors. It is intended to provide Information Security and platform teams with a quick overview for integrating CyberArk's Workload Identity Issuer with 'cert-manager<code>and</code>Istio` service-mesh. It is NOT intended to be used for production purposes.</p> <p>Please also not that the original Venafi product names are currently transitioning to CyberArk therefore the document uses both Venafi and CyberArk interchangeably.</p>","tags":["v0.1","DRAFT","In Progress"]},{"location":"os-quick-start/#overview","title":"Overview","text":"<p>This quick-start is intended to to provide a single point of reference for installing and configuring Firefly with cert-manager using the CyberArk OpenShift Operator.</p> <p>It will include the following components:</p> <ul> <li>Enterprise cert-manager: Enterprise cert-manager adds certificates and certificate issuers as resource types in Kubernetes clusters, and simplifies the process of obtaining, renewing and using certificates. Venafi provides Long-Term Support (LTS) releases of cert-manager to help organizations with lifecycle planning. Each LTS release is maintained for a minimum of two years.</li> <li>CyberArk Workload Identity Issuer: A lightweight, distributed, and cloud-native machine identity issuer, specifically designed to secure workloads in dynamic, cloud-native environments.  </li> </ul> <p>These enterprise components and are stored in a private repository.</p> <p>Users in the US, Canada, Australia, and Singapore regions should use the US registry. Users in the EU and UK should use the EU registry:</p> <ul> <li>US: oci://private-registry.venafi.cloud/</li> <li>EU: oci://private-registry.venafi.eu/</li> </ul> <p>Prerequisites</p> <p>To complete this quick-start you will need access to:</p> <ul> <li>A RedHat OpenShift Cluster You will need permissions that enable you to install the \"CyberArk Certificate Manager Operator\" You can learn more here: https://catalog.redhat.com/en/software/container-stacks/detail/65ba7a33a723d0b8f2df84b4</li> <li>Access to a CyberArk Certificate Manager Tenant (Formally Venafi TLS Protect Cloud) </li> <li>Successfully Installed the CyberArk Certificate Manager Operator for OpenShift</li> </ul> <p>You will also need to ensure that the following utilities are installed: </p> <ul> <li><code>kubectl</code> The Kubernetes CLI tool. This needs to be configured with the correct context to access the OpenShift cluster.</li> <li><code>venctl</code> A CLI tool that enables interaction with CyberArk Certificate Manager from the command line. You can install it from here: https://docs.venafi.cloud/vaas/venctl/t-venctl-install/</li> <li><code>imgpkg</code> A CLI  tool that allows users to store a set of arbitrary files as an OCI image. You can install it from here: https://github.com/carvel-dev/imgpkg</li> <li><code>jq</code> A lightweight CLI tool and flexible command-line JSON processor. You can install it from here: https://jqlang.org</li> <li><code>cmctl</code> A command line tool that can help you manage cert-manager and its resources inside your cluster. You can install it from here: https://cert-manager.io/docs/reference/cmctl/#installation</li> </ul> Step 1. Install the \"CyberArk Certificate Manager Operator for OpenShift <p>In this step we will create a new <code>cyberark</code> namespace within our OpenShift cluster and then install the CyberArk Certificate Manager Operator for OpenShift.</p> <p>1. Create a new name-space</p> Command<pre><code> kubectl create namespace cyberark\n</code></pre> <p>2. Install the OpenShift Operator</p> <p>a. Login to your OpenShift Cluster Console and navigate to \"Operators, OperatorHub\" in the left hand menu. Then type \"CyberArk\" in the search field. (See Example 1.)  b. Click \"Install\" (See Example 2.)  c. Click on the \"Installed Namespace\" drop-down and select \"CyberArk\", then click \"Install\" (See Example 3.)</p> <p></p> <p></p>    Example 1     Example 2          Example 3  <p></p> <p>Upon completion you should see:</p> <p> </p><p></p> <p></p> Step 2. Enable access to the private CyberArk OCI registry <p>In this step we will enable access to the private CyberArk OCI (Open Container Initiative) registry which stores the enterprise container images, Helm charts, and other artifacts. To save some time we'll use the <code>venctl</code> command line to get the credential. </p> <p>This step also requires access to a system where <code>jq</code> and <code>kubectl</code> are installed.</p> <p>A note about CyberArk OCI registries</p> <p>There are two types of registries: public and private.</p> <ul> <li>Public Registries: These are deployed in all available Venafi Control Plane regions and serve from a single location: registry.venafi.cloud. Public registries hold publicly available artifacts and do not require authentication.</li> <li> <p>Private Registries: These registries store enterprise Venafi software and are available in region-specific locations.   US region - private-registry.venafi.cloud   EU region - private-registry.venafi.eu   Users in the US, Canada, Australia, and Singapore regions should use the US registry. Users in the EU and UK should use the EU registry.   Access to these registries requires a subscription to the Venafi Control Plane. For your convenience, the private registries also contain the public artifacts hosted by the public registries.   There are two ways to acquire credentials to access the registry:</p> </li> <li> <p>Using the Venafi Control Plane UI</p> </li> <li>Using the CLI tool for CyberArk Certificate Manager</li> </ul> <p>Users in the US, Canada, Australia, and Singapore regions should use the US registry. Users in the EU and UK should use the EU registry:</p> <ul> <li>US: oci://private-registry.venafi.cloud/</li> <li>EU: oci://private-registry.venafi.eu/     </li> </ul> <p>1. Export the Venafi SaaS API Key</p> <p>a. Login to the Venafi SaaS Console and navigate to \"Account - Preferences\" in the top right of the screen (See Example 1.)  b. Copy the API key to your clipboard (See Example 2.)</p> <p></p> <p></p>    Example 1     Example 2  <p></p> <p>2. Save the API key as an environment variable</p> Command:<pre><code>export API_KEY=\"content from clipboard\"\n</code></pre> <p>3. Create an \"image pull\" credential</p> Command: Create an image pull credential<pre><code>venctl iam service-accounts registry create --name \"Enterprise Image Pull Secret\" \\  # (1)\n  --scopes cert-manager-components,enterprise-venafi-issuer,enterprise-approver-policy,openshift-routes \\\n  --output dockerconfig \\\n  --output-file venafi_registry_docker_config.json \\  # (2)\n  --validity 365 \\\n  --api-key $API_KEY  # (3)\n</code></pre> <ol> <li> This is the display name for the credential listed in the SaaS control plane under \"Service accounts\"</li> <li> This is the file name that will be used to store the new credential\"</li> <li> This is API key used to authenticate with the SaaS control plane under \"Account, Preferences\"    </li> </ol> <p>We now have three options for pulling images from the private repository. We can configure Kubernetes (option 1) to use the \"image pull\" credential so that it can directly pull images from the private repository. However, some orgnizations require helm charts and images to be pulled down and added \"mirrored\" (option 2) to their own private repositories. Alternatively, the charts and images can be downloaded (option 3) manually. </p>  Option 1 - Kubernetes/OS pulls Option 2 - Mirror the repository Option 3 - Manual download <p>This option will create a new \"image pull\" secret in Kubernetes that will enable Kubernetes to pull the CyberArk Enterprise components directly from the private repo   </p> <p>4. Create a new secret from the credential</p> Command: Create secret for image-pull<pre><code>kubectl create secret docker-registry venafi-image-pull-secret --namespace cyberark --from-file .dockerconfigjson=venafi_registry_docker_config.json\n</code></pre> <p>5. Inspect the secret</p> Command: Get secret<pre><code>kubectl get secret venafi-image-pull-secret --namespace venafi \\\n  --output=\"jsonpath={.data.\\.dockerconfigjson}\" \\\n  | base64 --decode \\\n  | jq\n</code></pre> <p>To set up Docker mirroring, follow the specific process for your mirroring tool, like Artifactory.</p> <p>4. Extract the username and password</p> command<pre><code>cat venafi_registry_docker_config.json \\\n| jq '.. | select(.username?) | \"username: \\(.username)\\npassword: \\(.auth)\"' -r\n</code></pre> <p>We'll use this option to download the helm charts and images for cert-manager and the Enterprise issuer using the <code>imgpkg</code> CLI utility. </p> <p>A note about imgpkg</p> <p><code>imgpkg</code> is a tool that allows users to store a set of arbitrary files as an OCI image. One of the driving use cases is to store Kubernetes configuration (plain YAML, ytt templates, Helm templates, etc.) in OCI registry as an image.</p> <p>You can install it from here: https://github.com/carvel-dev/imgpkg</p> <p>4. Extract the username and password</p> Command<pre><code>cat venafi_registry_docker_config.json \\\njq '.. | select(.username?) | \"username: \\(.username)\\npassword: \\(.auth)\"' -r\n</code></pre> <p>5. Login to the private repo using the username/password extracted from the above command**</p> command<pre><code>docker login private-registry.venafi.cloud \\\n--username $(cat venafi_registry_docker_config.json | jq '.. | select(.username?).username' -r) \\\n--password $(cat venafi_registry_docker_config.json | jq '.. | select(.username?).auth | @base64d' -r | cut -d: -f2)\n</code></pre> <p>6. Download the CyberArk Workload Issuer (Firefly) image and helm chart</p> command<pre><code>imgpkg copy --image registry.venafi.cloud/public/venafi-images/firefly:v1.8.1 --to-tar firefly-v1.3.1.tar\nimgpkg copy --image registry.venafi.cloud/public/venafi-images/helm/firefly:v1.8.1 --to-tar firefly-helm-v1.3.1.tar\n</code></pre> <p>7. Download cert-manger images and helm chart</p> <p></p>command<pre><code>imgpkg copy --image private-registry.venafi.cloud/cert-manager/cert-manager-controller:v1.18.2 --to-tar cert-manager-controller-v1.18.2.tar\nimgpkg copy --image private-registry.venafi.cloud/cert-manager/cert-manager-acmesolver:v1.18.2 --to-tar cert-manager-acmesolver-v1.18.2.tar\nimgpkg copy --image private-registry.venafi.cloud/cert-manager/cert-manager-cainjector:v1.18.2 --to-tar cert-manager-cainjector-v1.18.2.tar\nimgpkg copy --image private-registry.venafi.cloud/cert-manager/cert-manager-webhook:v1.18.2 --to-tar cert-manager-webhook-v1.18.2.tar\nimgpkg copy --image private-registry.venafi.cloud/cert-manager/cert-manager-startupapicheck:v1.18.2 --to-tar cert-manager-startupapicheck-v1.18.2.tar\nimgpkg copy --image private-registry.venafi.cloud/charts/cert-manager:v1.18.2 --to-tar cert-manager-helm-v1.18.2.tar\n</code></pre> 8. Publish the the CyberArk Workload Issuer (Firefly) image and chart to your own enterprise repository<p></p> <p></p>command<pre><code>imgpkg copy --tar firefly-v1.8.1.tar --to-repo enterprise-repo/firefly\nimgpkg copy --tar firefly-helm-v1.8.1.tar --to-repo enterprise-repo/firefly\n</code></pre> 9. Publish the cert-manger images and charts to your own repository<p></p> command<pre><code>imgpkg copy --tar cert-manager-controller-v1.18.2.tar --to-repo enterprise-repo/cert-manager-controller\nimgpkg copy --tar cert-manager-acmesolver-v1.18.2.tar --to-repo enterprise-repo/cert-manager-acmesolver\nimgpkg copy --tar cert-manager-cainjector-v1.18.2.tar --to-repo enterprise-repo/cert-manager-cainjector\nimgpkg copy --tar cert-manager-webhook-v1.18.2.tar --to-repo enterprise-repo/cert-manager-webhook\nimgpkg copy --tar cert-manager-startupapicheck-v1.18.2.tar --to-repo enterprise-repo/cert-manager-startupapicheck \nimgpkg copy --tar cert-manager-helm-v1.18.2.tar --to-repo enterprise-repo/cert-manager \n</code></pre> Step 3. Create a new service account <p>In this step we will create a new service account for Firefly. The service account is used by Firefly to connect to the control plane.</p> <p>1. Create a new service account for Firefly using the <code>venctl</code> CLI</p> Command<pre><code>venctl iam service-accounts firefly create \\\n  --name \"Firefly-OpenShift-tmp\" \\\n  --output-file \"cybr_mis_firefly_secret.json\" \\\n  --output \"secret\" \\\n  --owning-team \"Firefly Playground\" \\\n  --validity 10 \\\n  --api-key $API_KEY\n\njq -r '.private_key' \"cybr_mis_firefly_secret.json\" &gt; \"cybr_mis_firefly_secret.yaml\"\nexport SA_ID=$(jq -r '.client_id' \"cybr_mis_firefly_secret.json\")\n</code></pre> <p>2. Create a new secret using the private key from the service account</p> Command<pre><code>kubectl apply -n cyberark -f - &lt;&lt;EOF\n  $(cat cybr_mis_firefly_secret.yaml )\nEOF\n</code></pre> Step 4. Create a Firefly Policy <p>In this step we will create Firefly configuration </p> <p>1. Login to the Venafi Console and navigate to \"Policies - Workload Issuance Policies\" (See Example 1.)  2. Click \"New\" and complete the first part of the configuration - For now we'll leave the policy fairly open (See Example 2.)  3. Click \"Save\" </p> <p></p> <p></p>    Example 1     Example 2  <p></p> Step 5. Create a Firefly Configuration  <p>In this step we will create Firefly configuration </p> <ol> <li>Login to the Venafi Console and navigate to \"Configurations - Issuer Configurations\" (See Example 1.)</li> <li>Click \"New\" and complete the first part of the configuration (See Example 2.)</li> <li>Click \"Continue\" and complete the second part of the configuration (See Example 3.)</li> </ol> <p></p> <p></p>    Example 1     Example 2          Example 3  <p></p> Step 6. Install CyberArk Workload Issuer (Firefly)  <p>In this step we will install CyberArk Workload Issuer (Firefly) using the Venafi Operator </p> Command<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: installer.venafi.com/v1alpha1\nkind: VenafiInstall\nmetadata:\n  name: firefly-install\nspec:\n  venafiConnection:\n    install: true\n  certManager:\n    install: true\n  globals:\n    namespace: cyberark\n    region: US\n    imagePullSecretNames:\n      - venafi-image-pull-secret\n    vcpRegion: US\n    enableDefaultApprover: true\n  venafiEnhancedIssuer:\n    install: false\n    skip: true\n  firefly:\n    acceptTOS: true\n    clientID: $CLIENT_ID\n    install: true\n    values:\n      deployment:\n        config:\n          bootstrap:\n            vaas:\n              url: https://api.venafi.cloud\n          controller:\n            certManager:\n              caRootChainPopulation: true    \nEOF\n</code></pre> Step 7. Test the CyberArk Workload Issuer &amp; cert-manager  <p>In this step we will install CyberArk Workload Issuer (Firefly) using the Venafi Operator </p> Command<pre><code>kubectl apply -f - &lt;&lt;EOF\nkind: Certificate\napiVersion: cert-manager.io/v1\nmetadata:\n  name: 6goats.acme.com\n  namespace: cyberark\n  annotations:\n     firefly.venafi.com/policgit y-name: Firefly Playground\nspec:\n  privateKey:\n    rotationPolicy: Always\n  secretName: 6goats.acme.com\n  commonName: 6goats.acme.com\n  issuerRef:\n    name: firefly\n    kind: Issuer\n    group: firefly.venafi.com\nEOF\n</code></pre>","tags":["v0.1","DRAFT","In Progress"]}]}